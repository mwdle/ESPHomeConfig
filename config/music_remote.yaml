packages:
  - !include common/esp8266_nodemcuv2.yaml

substitutions:
  device_name: music-remote
  friendly_name: Music Remote
  device_description: ESP8266-Based Remote for Music Assistant
  # Both of the following media_player entities refer to the same physical media player, but behave differently because they are provided by different integrations in Home Assistant.
  # Both are necessary to ensure that all media playback controls can function properly regardless of the current media source (e.g. Music Assistant, Spotify, Poweramp, etc).
  media_player_mass: media_player.audio # Music Assistant integration provided media_player entity
  media_player_direct: media_player.audio_direct # Google Cast integration provided media_player entity

esphome:
  # This configuration requires the music_remote.h file which contains implementation for all display rendering, playlist management, and more.
  includes:
    - music_remote.h

font:
  - file:
      url: "https://raw.githubusercontent.com/googlefonts/opensans/main/fonts/ttf/OpenSans-Regular.ttf"
      type: web
    id: opensans_12
    size: 12
    glyphs: "@%’&!¡\"\\'()+,-_.:°/$#€£¥?0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyzÀàÁáÃãçÈèÉéẼẽÌìÍíÑñôÒòÓóÕõØøŚśÙùÚúŨũ"
  - file:
      url: "https://raw.githubusercontent.com/googlefonts/opensans/main/fonts/ttf/OpenSans-Regular.ttf"
      type: web
    id: opensans_10
    size: 10
    glyphs: "@%’&!¡\"\\'()+,-_.:°/$#€£¥?0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyzÀàÁáÃãçÈèÉéẼẽÌìÍíÑñôÒòÓóÕõØøŚśÙùÚúŨũ"
  - file:
      url: "https://raw.githubusercontent.com/Templarian/MaterialDesign-Webfont/master/fonts/materialdesignicons-webfont.ttf"
      type: web
    id: mdi_16
    size: 16
    glyphs: [
        "󰖩", # wifi
        "󰖪", # wifi-off
        "󰄘", # cast
        "󰄙", # cast-connected
        "󰃟", # brightness-6
        "󰀟", # cast-variant
        "󰋼", # information
      ]
  - file:
      url: "https://raw.githubusercontent.com/Templarian/MaterialDesign-Webfont/master/fonts/materialdesignicons-webfont.ttf"
      type: web
    id: mdi_18
    size: 18
    glyphs: [
        "󱬐", # volume-equal
        "󰕾", # volume-high
      ]
  - file:
      url: "https://raw.githubusercontent.com/Templarian/MaterialDesign-Webfont/master/fonts/materialdesignicons-webfont.ttf"
      type: web
    id: mdi_20
    size: 20
    glyphs: [
        "󰲸", # playlist-music
      ]
  - file:
      url: "https://raw.githubusercontent.com/Templarian/MaterialDesign-Webfont/master/fonts/materialdesignicons-webfont.ttf"
      type: web
    id: mdi_21
    size: 21
    glyphs: [
        "󰏤", # pause
        "󰐊", # play
        "󰒮", # skip-previous
        "󰒭", # skip-next
      ]

i2c:
  sda: D7
  scl: D6
  scan: true
  frequency: 400khz # Default of 50khz breaks Wi-Fi due to blocking delays? Higher values increase power consumption but yield faster display updates.

# Balance/reduce OLED burn-in by inverting the display colors each minute
interval:
  - interval: 1min
    then:
      - lambda: |-
          static bool inverted = false;
          inverted = !inverted;
          id(screen).set_invert(inverted);

globals:
  - id: selected_playlist
    type: int
    initial_value: "0"
  - id: playlists
    type: std::vector<char*>

display:
  - platform: ssd1306_i2c
    id: screen
    model: "SSD1306 128x64"
    address: 0x3C
    rotation: 180°
    contrast: 0% # Use the lowest "brightness" to save battery life (ESPHome brightness attribute doesn't work for SSD1306, use contrast instead)
    update_interval: 42ms # ~24fps
    on_page_change:
      - to: playlistSelectionPage
        then:
          - homeassistant.action:
              action: music_assistant.get_library
              data:
                media_type: playlist
              data_template:
                config_entry_id: "{{ config_entry_id('${media_player_mass}') }}"
              capture_response: true
              response_template: "{{ response['items'] | map(attribute='name') | list }}" # Map the JSON response from Music Assistant into a list of playlist names
              on_success:
                - lambda: load_playlists_from_json(response); # Load the JSON array of playlist names from response_template (see music_remote.h)
              on_error:
                - logger.log:
                    format: "Failed to get playlists: %s"
                    level: WARN
                    args: ["error.c_str()"]
    pages:
      - id: playbackPage
        lambda: |-
          // Draw the currently playing song title and artist
          render_active_media();
          // Draw common UI controls:
          render_ui_controls();
      - id: playlistSelectionPage
        lambda: |-
          // Draw Playlist Selection UI
          render_playlist_selection();
          // Draw common UI controls:
          render_ui_controls();
      - id: statsPage
        lambda: |-
          // Draw connection statistics (such as wifi, HA API connection status, etc)
          render_statistics();
          // Draw common UI controls
          render_ui_controls();

binary_sensor:
  - platform: gpio
    internal: true
    pin:
      number: TX
      inverted: true
      mode:
        input: true
        pullup: true
    id: play_selected_playlist_button # Rotary Encoder button
    on_press:
      then:
        - if:
            condition:
              lambda: "return id(screen).get_active_page() == id(playlistSelectionPage);" # Only register encoder button presses if user is on playlist selection page
            then:
              - homeassistant.action:
                  action: music_assistant.play_media
                  data:
                    entity_id: ${media_player_mass} # Playlist selection is only available for the Music Assistant Integration provided player
                    media_type: playlist
                    enqueue: replace
                  data_template:
                    media_id: "{{ playlist }}"
                  variables:
                    playlist: !lambda "return id(playlists).at(id(selected_playlist));"
              - display.page.show: playbackPage
  - platform: gpio
    internal: true
    pin:
      number: RX
      mode:
        input: true
        pullup: true
    id: next_page_button
    on_press:
      - display.page.show_next: screen
  - platform: gpio
    internal: true
    pin:
      number: D3
      mode:
        input: true
        pullup: true
    id: media_previous_track
    trigger_on_initial_state: true
    on_multi_click:
      - timing: # on short press
          - OFF for at most 1s
          - ON for at least 0.05s
        then:
          - if:
              condition:
                lambda: 'return id(media_source).state == "Music Assistant";'
              then:
                - homeassistant.action:
                    action: media_player.media_previous_track
                    data:
                      entity_id: ${media_player_mass}
              else:
                - homeassistant.action:
                    action: media_player.media_previous_track
                    data:
                      entity_id: ${media_player_direct}
      - timing: # on long press
          - OFF for at least 1.05s
        then:
          - if:
              condition:
                lambda: 'return id(media_source).state == "Music Assistant";'
              then:
                - homeassistant.action:
                    action: media_player.media_seek
                    data:
                      entity_id: ${media_player_mass} # Fast forward using the Music Assistant Integration provided player
                    data_template:
                      seek_position:
                        >- # The media position attribute only updates when a song starts, ends, or when the user interacts with playback (e.g. scrubbing, play/pause, etc). Therefore, to determine the correct position, we need to compare the current time to the media_position_updated_at attribute.
                        {% set new_position = (int((now() - state_attr("${media_player_mass}",
                        "media_position_updated_at")).seconds + state_attr("${media_player_mass}",
                        "media_position")) - 15) %} 
                        {% if new_position >= 0 %} 
                        {{ new_position }} 
                        {% else %} 
                        {{ 0 }} 
                        {% endif %}
              else:
                - homeassistant.action:
                    action: media_player.media_seek
                    data:
                      entity_id: ${media_player_direct} # Fast forward using Google Cast Integration provided player
                    data_template:
                      seek_position:
                        >- # The media position attribute only updates when a song starts, ends, or when the user interacts with playback (e.g. scrubbing, play/pause, etc). Therefore, to determine the correct position, we need to compare the current time to the media_position_updated_at attribute.
                        {% set new_position = (int((now() - state_attr("${media_player_direct}",
                        "media_position_updated_at")).seconds + state_attr("${media_player_direct}",
                        "media_position")) - 15) %} 
                        {% if new_position >= 0 %} 
                        {{ new_position }} 
                        {% else %} 
                        {{ 0 }} 
                        {% endif %}
  - platform: gpio
    internal: true
    pin:
      number: D4
      mode:
        input: true
        pullup: true
    id: media_play_pause
    on_press:
      - homeassistant.action:
          action: media_player.media_play_pause
          data:
            entity_id: ${media_player_mass} # Always play/pause on the Music Assistant Integration provided player to allow resuming the MA queue at player idle. Play/pause works correctly regardless of media source using the MA provided action.
  - platform: gpio
    internal: true
    pin:
      number: D5
      mode:
        input: true
        pullup: true
    id: media_volume_sync
    on_press:
      - homeassistant.action:
          action:
            script.sync_audio_group_volume # This is a custom Home Assistant script that synchronizes/balances the volume between my Chromecast Audio powered sound system and a Google Nest Mini which are paired in an audio group. See the HA YAML below:
            # alias: Sync Audio Group Volume
            # sequence:
            #   - condition: template
            #     value_template: >-
            #       {% set volume_difference =
            #       int(((state_attr("media_player.michael_s_nest_mini", "volume_level") -
            #       state_attr("media_player.michael_s_speakers",
            #       "volume_level"))*100)|abs|round(0)) %}
            #       {{ volume_difference < 7 or volume_difference > 9 }}
            #   - variables:
            #       new_nest_mini_volume: >-
            #         {% set new_volume = state_attr('media_player.michael_s_speakers',
            #         'volume_level') + 0.08 %} {% if new_volume > 1 %} {{ 1.0 }} {% else %}
            #         {{ new_volume }} {% endif %}
            #   - metadata: {}
            #     data:
            #       volume_level: "{{ new_nest_mini_volume }}"
            #     action: media_player.volume_set
            #     target:
            #       entity_id: media_player.michael_s_nest_mini
            # description: ""
            # icon: mdi:sync
  - platform: gpio
    internal: true
    pin:
      number: D8
      inverted: true
      mode:
        input: true # Internal pullup not available on D8, needs external pullup resistor
    id: media_next_track
    trigger_on_initial_state: true
    on_multi_click:
      - timing: # on short press
          - OFF for at most 1s
          - ON for at least 0.05s
        then:
          - if:
              condition:
                lambda: 'return id(media_source).state == "Music Assistant";'
              then:
                - homeassistant.action:
                    action: media_player.media_next_track
                    data:
                      entity_id: ${media_player_mass} # Skip using the Music Assistant Integration provided player
              else:
                - homeassistant.action:
                    action: media_player.media_next_track
                    data:
                      entity_id: ${media_player_direct} # Skip using Google Cast Integration provided player
      - timing: # on long press
          - OFF for at least 1.05s
        then:
          - if:
              condition:
                lambda: 'return id(media_source).state == "Music Assistant";'
              then:
                - homeassistant.action:
                    action: media_player.media_seek
                    data:
                      entity_id: ${media_player_mass} # Fast forward using the Music Assistant Integration provided player
                    data_template:
                      seek_position:
                        >- # The media position attribute only updates when a song start, ends, or when the user interacts with playback (e.g. scrubbing, play/pause, etc). Therefore, to determine the correct position, we need to compare the current time to the media_position_updated_at attribute.
                        {% set new_position = (int((now() - state_attr("${media_player_mass}",
                        "media_position_updated_at")).seconds + state_attr("${media_player_mass}",
                        "media_position")) + 15) %} 
                        {% if new_position < state_attr("${media_player_mass}", "media_duration") %} 
                        {{ new_position }} 
                        {% else %} 
                        {{ state_attr("${media_player_mass}", "media_duration") - 1 }} 
                        {% endif %}
              else:
                - homeassistant.action:
                    action: media_player.media_seek
                    data:
                      entity_id: ${media_player_direct} # Fast forward using Google Cast Integration provided player
                    data_template:
                      seek_position:
                        >- # The media position attribute only updates when a song starts, ends, or when the user interacts with playback (e.g. scrubbing, play/pause, etc). Therefore, to determine the correct position, we need to compare the current time to the media_position_updated_at attribute.
                        {% set new_position = (int((now() - state_attr("${media_player_direct}",
                        "media_position_updated_at")).seconds + state_attr("${media_player_direct}",
                        "media_position")) + 15) %} 
                        {% if new_position < state_attr("${media_player_direct}", "media_duration") %} 
                        {{ new_position }} 
                        {% else %} 
                        {{ state_attr("${media_player_direct}", "media_duration") - 1 }} 
                        {% endif %}

sensor:
  - platform: rotary_encoder
    name: "Volume"
    id: volume
    pin_a:
      number: D2
      mode:
        input: true
        pullup: true
    pin_b:
      number: D1
      mode:
        input: true
        pullup: true
    publish_initial_value: true
    on_clockwise:
      then:
        - if:
            condition:
              lambda: "return id(screen).get_active_page() == id(playlistSelectionPage);"
            then:
              - lambda: "if (id(playlists).size() > 0) id(selected_playlist) = (id(selected_playlist) + 1) % id(playlists).size();"
            else:
              - homeassistant.action:
                  action: media_player.volume_up
                  data:
                    entity_id: ${media_player_mass} # Only adjust volume via the Music Assistant Integration provided player since it offers finer grain control compared to the Google Cast Integration provided player.
    on_anticlockwise:
      then:
        - if:
            condition:
              lambda: "return id(screen).get_active_page() == id(playlistSelectionPage);"
            then:
              - lambda: "if (id(playlists).size() > 0) id(selected_playlist) = (id(selected_playlist) - 1 + id(playlists).size()) % id(playlists).size();"
            else:
              - homeassistant.action:
                  action: media_player.volume_down
                  data:
                    entity_id: ${media_player_mass} # Only adjust volume via the Music Assistant Integration provided player since it offers finer grain control compared to the Google Cast Integration provided player.
    filters:
      - debounce: 10ms
    internal: true
  - platform: homeassistant
    id: media_volume
    entity_id: ${media_player_direct}
    attribute: volume_level
    unit_of_measurement: "%"
    internal: true

text_sensor:
  - platform: homeassistant
    id: media_title
    entity_id: ${media_player_direct} # Fetch the current media title directly from the Google Cast Integration provided player as it works regardless of media source.
    attribute: media_title
    internal: true
  - platform: homeassistant
    id: media_artist
    entity_id: ${media_player_direct} # Fetch the current media artist directly from the Google Cast Integration provided player as it works regardless of media source.
    attribute: media_artist
    internal: true
  - platform: homeassistant
    id: media_status
    entity_id: ${media_player_direct} # Fetch the current media status directly from the Google Cast Integration provided player as it works regardless of media source.
    internal: true
  - platform: homeassistant
    id: media_source
    entity_id: ${media_player_direct} # Fetch the current media source directly from the Google Cast Integration provided player as it works regardless of media source.
    attribute: app_name
    internal: true
